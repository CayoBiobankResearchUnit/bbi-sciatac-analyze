#from analysis.motifs import Motifs # motifs from above
from pybedtools import BedTool
from collections import OrderedDict
from statsmodels import robust
from scipy.io import mmwrite
import argparse
import os
from collections import Counter
import scipy.sparse as sp
import numpy as np
import subprocess
from call_peak_motifs import Motifs
import io_functions


def motifscan_bed_to_sparse_matrix(scan_beds, peak_idx, motif_idx, format='binary'):
    """

    :param scan_beds: List of file names containing motif annotations in peaks
    :param peak_idx: an OrderedDict of peak coordinates to integer mapping
    :param motif_idx: an OrderedDict of motif name to integer mapping
    :param format: output of the sparse matrix is either binary or count
    :return: a scipy.sparse.csc_matrix
    """
    assert format in ['count', 'binary']

    tf_peak_counter = Counter()
    peak_coor = []
    motif_coor = []
    values = []
    
    current_chromosome = None
    for file_name in scan_beds:
        for row in open(file_name):
            row = row.strip().split('\t')
            chromosome = row[0]
            if current_chromosome != chromosome:
                print("Processing chromsome %s..." % chromosome)
                current_chromosome = chromosome
            
            peak_id = peak_idx['_'.join(row[:3])]
            motif_id = motif_idx[row[3]]

            if format == 'count':
                tf_peak_counter[(peak_id, motif_id)] += 1
            elif format == 'binary':
                tf_peak_counter[(peak_id, motif_id)] = 1

    for key, v in tf_peak_counter.items():
        peak_coor.append(key[0])
        motif_coor.append(key[1])
        values.append(v)

    return peak_coor, motif_coor, values


def _get_peak_indexes(peaks):
    """
    :param peaks: BedTool object
    """
    out_dict = OrderedDict()
    for i, peak in enumerate(peaks):
        peak_id = str('_'.join(peak[:3]))
        out_dict[peak_id] = i
    return out_dict, i + 1


def _get_motif_indexes(motifs):
    """
    :param motif: Motifs object
    """
    out_dict = OrderedDict()
    for i, motif in enumerate(motifs.all_motifs):
        motif_id = motif.name
        out_dict[motif_id] = i
    return out_dict, i + 1

def MADzscore(matrix, axis=1):
    '''Expects a numpy matrix and returns a zscore matrix. This is robust to 1-D outliers as
    it normalizes the distance from the median using the median absolute distance from the median.
    More: https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm#Z-Scores'''
    assert matrix.ndim == 2
    medians = np.median(matrix, axis=axis, keepdims=True)
    MAD = np.expand_dims(robust.mad(matrix, axis=axis), axis=axis)
    return (matrix - medians) / MAD


if __name__ == '__main__':
    parser = argparse.ArgumentParser('Script to generate a cell by motif matrix given a binarized count matrix and motif calls on peaks.')
    parser.add_argument('--peak_motif_files', nargs='+', required=True, help='List of files containing calls on peaks as generated by PeakMotifs stage.')
    parser.add_argument('--fasta', help='Fasta used for motif calling.')
    parser.add_argument('--peaks', help='Peaks used for motif calling.')
    parser.add_argument('--motifs', help='Motifs input used for motif calling.')
    parser.add_argument('--peak_tf_matrix', help='Peak-TF matrix of counts.')
    args = parser.parse_args()

    peaks = BedTool(args.peaks)
    motifs = Motifs(args.fasta, args.motifs)

    # Convert to sparse matrix
    print('Loading features...')
    ## extract peak coordinate to numerical index map
    peak_idx, n_peaks = _get_peak_indexes(peaks)

    ## extract motif names to numerical index map
    motif_idx, n_motifs = _get_motif_indexes(motifs)

    ## extract 3 lists: peak indexes, motif indexes and counts, each entry correspond to a peak-motif pair
    print('Building matrix...')
    peak_coor, motif_coor, values = motifscan_bed_to_sparse_matrix(args.peak_motif_files, peak_idx, motif_idx, format='binary')

    ## convert it to a sparse matrix, default is binary format, motifs are rows and peaks are columns
    tf_peak_matrix = sp.csc_matrix((values, (motif_coor, peak_coor)), shape=(n_motifs, n_peaks), dtype='int32')
    motif_names = motif_idx.keys()
    peak_names = peak_idx.keys()

    # Write output
    print("Writing output file...")
    io_functions.write_mtx_file(tf_peak_matrix, motif_names, peak_names, args.peak_tf_matrix)
    print('Done.')

